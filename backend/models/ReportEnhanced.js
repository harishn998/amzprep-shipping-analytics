// ============================================================================
// ENHANCED REPORT MODEL WITH METADATA SUPPORT
// File: backend/models/ReportEnhanced.js
// ============================================================================

import mongoose from 'mongoose';

const reportSchema = new mongoose.Schema({
  // User who created the report
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  userEmail: {
    type: String,
    required: true,
    index: true
  },

  // Report metadata
  filename: {
    type: String,
    required: true
  },
  uploadDate: {
    type: Date,
    default: Date.now,
    index: true
  },

  // Upload and rate type
  uploadType: {
    type: String,
    enum: ['amazon', 'shopify'],
    default: 'amazon',
    index: true
  },
  rateType: {
    type: String,
    enum: ['prep', 'middleMile', 'fbaShipment', 'combined', 'orderUpdate', 'productUpdate'],
    default: 'prep',
    index: true
  },

  // Basic analytics data
  totalShipments: {
    type: Number,
    required: true
  },
  avgWeight: {
    type: Number,
    required: true
  },
  avgCost: {
    type: mongoose.Schema.Types.Mixed,  // Can be number or "Not available"
    required: true
  },
  analysisMonths: {
    type: Number,
    required: true
  },

  // Date range
  dateRange: {
    start: String,
    end: String
  },

  // Domestic vs International
  domesticVsInternational: {
    domestic: Number,
    international: Number,
    domesticPercent: String,
    internationalPercent: String
  },

  // Top states
  topStates: [{
    state: String,
    count: Number,
    units: Number,
    pallets: Number,
    volume: Number,
    weight: Number,
    percentage: Number
  }],

  // Warehouse/Provider comparison
  warehouseComparison: [{
    name: String,
    fullAddress: String,
    region: String,
    specialty: String,
    costMultiplier: Number,
    avgZone: Number,
    transitTime: Number,
    cost: Number,
    savings: Number,
    savingsPercent: String,
    shipments: Number,
    recommended: Boolean
  }],

  // Shipping methods
  shippingMethods: [{
    name: String,
    count: Number,
    percentage: Number
  }],

  // Weight distribution
  weightDistribution: [{
    range: String,
    count: Number
  }],

  // Zone distribution
  zoneDistribution: [{
    zone: Number,
    count: Number,
    percentage: String
  }],

  // ============================================================================
  // ENHANCED METADATA - Stores detailed analysis
  // ============================================================================
  metadata: {
    // Data format detection
    dataFormat: {
      type: String,
      enum: ['smash_foods', 'amazon_seller_central', 'generic_shipment', 'shopify_orders'],
      default: 'generic_shipment'
    },

    // Current provider costs breakdown
    currentCosts: {
      totalFreight: Number,
      totalPlacementFees: Number,
      totalCost: Number,
      costPerCuft: Number,
      costPerUnit: Number,
      costPerPallet: Number
    },

    // Proposed costs with different rate types
    proposedCosts: {
      prep: {
        totalCost: Number,
        breakdown: [{
          type: String,
          description: String,
          quantity: Number,
          rate: Number,
          cost: Number
        }]
      },
      middleMile: {
        totalCost: Number,
        breakdown: [{
          state: String,
          cost: Number,
          transitDays: Number,
          pallets: Number
        }]
      },
      combined: {
        totalCost: Number
      }
    },

    // Savings calculation
    savings: {
      amount: Number,
      percent: Number,
      currentTotal: Number,
      proposedTotal: Number
    },

    // Recommendations generated by analysis
    recommendations: [{
      type: {
        type: String,
        enum: ['cost_savings', 'transit_time', 'prep_time', 'consolidation', 'routing']
      },
      title: String,
      description: String,
      impact: {
        type: String,
        enum: ['low', 'medium', 'high']
      },
      savings: Number,
      improvement: Number
    }],

    // Carrier information
    carriers: [{
      name: String,
      count: Number,
      percentage: Number
    }],

    // Timeline metrics
    avgPrepTime: Number, // Days from order to shipment
    avgTransitTime: Number, // Days in transit

    // Shipment splitting analysis
    splitShipments: Number,
    splitShipmentRate: Number, // Percentage

    // Additional metrics
    totalUnits: Number,
    totalPallets: Number,
    totalVolume: Number,
    totalWeight: Number,
    uniqueSKUs: Number,

    // State-level detailed breakdown
    stateDetails: {
      type: Map,
      of: {
        count: Number,
        units: Number,
        pallets: Number,
        volume: Number,
        weight: Number,
        placementFees: Number,
        freight: Number,
        shipmentCount: Number
      }
    },

    // Raw shipment sample (first 10 for reference)
    shipmentSample: [{
      shipmentId: String,
      shipmentName: String,
      destinationFC: String,
      destinationAddress: String,
      orderDate: String,
      shipDate: String,
      units: Number,
      pallets: Number,
      volume: Number,
      weight: Number,
      carrier: String,
      transportMode: String,
      placementFee: Number,
      estFreight: Number
    }]
  }

}, {
  timestamps: true  // Automatically adds createdAt and updatedAt
});

// ============================================================================
// INDEXES
// ============================================================================

reportSchema.index({ userId: 1, uploadDate: -1 });
reportSchema.index({ userEmail: 1, uploadDate: -1 });
reportSchema.index({ uploadDate: -1 });
reportSchema.index({ uploadType: 1, rateType: 1 });
reportSchema.index({ 'metadata.dataFormat': 1 });

// ============================================================================
// VIRTUAL PROPERTIES
// ============================================================================

// Calculate ROI based on savings
reportSchema.virtual('roi').get(function() {
  if (this.metadata && this.metadata.savings && this.metadata.savings.currentTotal > 0) {
    const roi = (this.metadata.savings.amount / this.metadata.savings.currentTotal) * 100;
    return parseFloat(roi.toFixed(2));
  }
  return 0;
});

// Check if report has recommendations
reportSchema.virtual('hasRecommendations').get(function() {
  return this.metadata &&
         this.metadata.recommendations &&
         this.metadata.recommendations.length > 0;
});

// Get high-impact recommendations count
reportSchema.virtual('highImpactRecommendations').get(function() {
  if (!this.metadata || !this.metadata.recommendations) return 0;
  return this.metadata.recommendations.filter(r => r.impact === 'high').length;
});

// ============================================================================
// INSTANCE METHODS
// ============================================================================

// Get report summary (lightweight for list views)
reportSchema.methods.getSummary = function() {
  return {
    id: this._id,
    filename: this.filename,
    uploadDate: this.uploadDate,
    uploadType: this.uploadType,
    rateType: this.rateType,
    totalShipments: this.totalShipments,
    avgCost: this.avgCost,
    analysisMonths: this.analysisMonths,
    savings: this.metadata?.savings?.amount || 0,
    savingsPercent: this.metadata?.savings?.percent || 0,
    hasRecommendations: this.hasRecommendations,
    roi: this.roi
  };
};

// Get detailed cost breakdown
reportSchema.methods.getCostBreakdown = function() {
  return {
    current: this.metadata?.currentCosts || {},
    proposed: this.metadata?.proposedCosts || {},
    savings: this.metadata?.savings || {},
    recommendations: this.metadata?.recommendations || []
  };
};

// Get shipping efficiency metrics
reportSchema.methods.getEfficiencyMetrics = function() {
  return {
    avgPrepTime: this.metadata?.avgPrepTime || 0,
    avgTransitTime: this.metadata?.avgTransitTime || 0,
    splitShipmentRate: this.metadata?.splitShipmentRate || 0,
    topCarrier: this.metadata?.carriers?.[0]?.name || 'Unknown',
    topState: this.topStates?.[0]?.state || 'Unknown'
  };
};

// Compare with another report
reportSchema.methods.compareWith = async function(otherReportId) {
  const OtherReport = this.constructor;
  const otherReport = await OtherReport.findById(otherReportId);

  if (!otherReport) {
    throw new Error('Comparison report not found');
  }

  return {
    thisReport: {
      id: this._id,
      filename: this.filename,
      rateType: this.rateType,
      totalCost: this.metadata?.currentCosts?.totalCost || this.avgCost,
      transitTime: this.metadata?.avgTransitTime || 0
    },
    otherReport: {
      id: otherReport._id,
      filename: otherReport.filename,
      rateType: otherReport.rateType,
      totalCost: otherReport.metadata?.currentCosts?.totalCost || otherReport.avgCost,
      transitTime: otherReport.metadata?.avgTransitTime || 0
    },
    comparison: {
      costDifference: (this.metadata?.currentCosts?.totalCost || this.avgCost) -
                     (otherReport.metadata?.currentCosts?.totalCost || otherReport.avgCost),
      transitTimeDifference: (this.metadata?.avgTransitTime || 0) -
                            (otherReport.metadata?.avgTransitTime || 0)
    }
  };
};

// ============================================================================
// STATIC METHODS
// ============================================================================

// Get reports by rate type
reportSchema.statics.getByRateType = async function(userId, rateType) {
  return await this.find({ userId, rateType })
    .sort({ uploadDate: -1 })
    .select('-metadata.shipmentSample'); // Exclude large fields
};

// Get aggregate statistics for user
reportSchema.statics.getUserStats = async function(userId) {
  const stats = await this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId) } },
    {
      $group: {
        _id: null,
        totalReports: { $sum: 1 },
        totalShipments: { $sum: '$totalShipments' },
        avgSavings: { $avg: '$metadata.savings.amount' },
        totalSavings: { $sum: '$metadata.savings.amount' },
        uploadTypes: { $addToSet: '$uploadType' },
        rateTypes: { $addToSet: '$rateType' }
      }
    }
  ]);

  return stats[0] || {
    totalReports: 0,
    totalShipments: 0,
    avgSavings: 0,
    totalSavings: 0,
    uploadTypes: [],
    rateTypes: []
  };
};

// Get savings trend over time
reportSchema.statics.getSavingsTrend = async function(userId, months = 6) {
  const startDate = new Date();
  startDate.setMonth(startDate.getMonth() - months);

  return await this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        uploadDate: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: {
          year: { $year: '$uploadDate' },
          month: { $month: '$uploadDate' }
        },
        totalSavings: { $sum: '$metadata.savings.amount' },
        avgSavingsPercent: { $avg: '$metadata.savings.percent' },
        reportCount: { $sum: 1 }
      }
    },
    { $sort: { '_id.year': 1, '_id.month': 1 } }
  ]);
};

// Find best performing rate type for user
reportSchema.statics.getBestRateType = async function(userId) {
  const result = await this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId) } },
    {
      $group: {
        _id: '$rateType',
        avgSavings: { $avg: '$metadata.savings.amount' },
        avgSavingsPercent: { $avg: '$metadata.savings.percent' },
        count: { $sum: 1 }
      }
    },
    { $sort: { avgSavings: -1 } },
    { $limit: 1 }
  ]);

  return result[0] || null;
};

// ============================================================================
// PRE-SAVE HOOKS
// ============================================================================

// Ensure metadata exists
reportSchema.pre('save', function(next) {
  if (!this.metadata) {
    this.metadata = {};
  }
  next();
});

// Calculate and cache derived values
reportSchema.pre('save', function(next) {
  // Ensure warehouseComparison has recommended flag set
  if (this.warehouseComparison && this.warehouseComparison.length > 0) {
    // Mark the option with highest savings as recommended
    const maxSavings = Math.max(...this.warehouseComparison.map(w => w.savings || 0));
    this.warehouseComparison.forEach(warehouse => {
      warehouse.recommended = warehouse.savings === maxSavings && maxSavings > 0;
    });
  }
  next();
});

const ReportEnhanced = mongoose.model('ReportEnhanced', reportSchema);

export default ReportEnhanced;
